<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Executive summary</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>Author: Rainer-Anton Englisch</p>

<h2>Executive summary</h2>

<p>The task of the course project can be summarized by a quote of the course projects summary:
&ldquo;Using devices such as Jawbone Up, Nike FuelBand, and Fitbit it is now possible to collect a large amount of data about personal activity relatively inexpensively. These type of devices are part of the quantified self movement - a group of enthusiasts who take measurements about themselves regularly to improve their health, to find patterns in their behavior, or because they are tech geeks. One thing that people regularly do is quantify how much of a particular activity they do, but they rarely quantify how well they do it. In this project, your goal will be to use data from accelerometers on the belt, forearm, arm, and dumbell of 6 participants. They were asked to perform barbell lifts correctly and incorrectly in 5 different ways. More information is available from the website here: <a href="http://groupware.les.inf.puc-rio.br/har">http://groupware.les.inf.puc-rio.br/har</a> (see the section on the Weight Lifting Exercise Dataset).&rdquo;</p>

<p>Simply put: We want to build a prediction model to predict activity quality from activity monitors. </p>

<h2>Predictor Analysis and Reduction</h2>

<p>Before letting caret to create a prediction model we will try to reduce the number of predictors in order to speed up the creation of the prediction model. First we load the training data set and then remove some obvious predictors that could lead to overfitting: Namely the column &ldquo;X&rdquo;&ldquo; and all the timestamp columns.</p>

<p>The activity quality of an observation is classified by the factor variable classe which we store in seperate variables for later use for training and prediction.</p>

<pre><code class="r">library(caret)
set.seed(1312)
pml_training = read.csv(&quot;pml-training.csv&quot;)
pml_training = pml_training[,-1]
winColIndex &lt;-  grep(&quot;window&quot;,colnames(pml_training))
pml_training = pml_training[,-winColIndex]
timestampColIndex &lt;-  grep(&quot;timestamp&quot;,colnames(pml_training))
pml_training = pml_training[,-timestampColIndex]
dim(pml_training)
</code></pre>

<pre><code>## [1] 19622   154
</code></pre>

<h3>Create training and test/validation data set</h3>

<p>Next we split the original training in a new training and a test data. The test data will be used later for estimating the out of sample error.</p>

<p>The activity quality of an observation is classified by the factor variable <strong>classe</strong> which we store in seperate variables for later use for training and prediction.</p>

<pre><code class="r">library(caret)
inTrain &lt;- createDataPartition(pml_training$classe,p=0.8, list=FALSE)
training &lt;- pml_training[inTrain,]
trainclasse &lt;- training$classe
testing &lt;- pml_training[-inTrain,]
testingclasse &lt;- testing$classe
</code></pre>

<h3>Remove predictors with near zero variability</h3>

<p>Next we throw out all predictors that have near zero variability because we assume
that these predictors have minimal influence on the prediction.</p>

<pre><code class="r">nZV &lt;- nearZeroVar(training,saveMetrics=TRUE)
# extract the predictor names which have near zero variability
nzvcolnames &lt;- rownames(nZV[nZV$nzv==TRUE,])
# compute the index of these predictor  names in the training data frame
nzvcolindex &lt;- which(names(training) %in% nzvcolnames)
# remove these predictors
training &lt;- training[,-nzvcolindex]
# print these predictors
nzvcolnames
</code></pre>

<pre><code>##  [1] &quot;kurtosis_roll_belt&quot;      &quot;kurtosis_picth_belt&quot;     &quot;kurtosis_yaw_belt&quot;       &quot;skewness_roll_belt&quot;      &quot;skewness_roll_belt.1&quot;   
##  [6] &quot;skewness_yaw_belt&quot;       &quot;max_yaw_belt&quot;            &quot;min_yaw_belt&quot;            &quot;amplitude_yaw_belt&quot;      &quot;avg_roll_arm&quot;           
## [11] &quot;stddev_roll_arm&quot;         &quot;var_roll_arm&quot;            &quot;avg_pitch_arm&quot;           &quot;stddev_pitch_arm&quot;        &quot;var_pitch_arm&quot;          
## [16] &quot;avg_yaw_arm&quot;             &quot;stddev_yaw_arm&quot;          &quot;var_yaw_arm&quot;             &quot;kurtosis_roll_arm&quot;       &quot;kurtosis_picth_arm&quot;     
## [21] &quot;kurtosis_yaw_arm&quot;        &quot;skewness_roll_arm&quot;       &quot;skewness_pitch_arm&quot;      &quot;skewness_yaw_arm&quot;        &quot;max_roll_arm&quot;           
## [26] &quot;min_roll_arm&quot;            &quot;amplitude_roll_arm&quot;      &quot;amplitude_pitch_arm&quot;     &quot;kurtosis_roll_dumbbell&quot;  &quot;kurtosis_picth_dumbbell&quot;
## [31] &quot;kurtosis_yaw_dumbbell&quot;   &quot;skewness_roll_dumbbell&quot;  &quot;skewness_pitch_dumbbell&quot; &quot;skewness_yaw_dumbbell&quot;   &quot;max_yaw_dumbbell&quot;       
## [36] &quot;min_yaw_dumbbell&quot;        &quot;amplitude_yaw_dumbbell&quot;  &quot;kurtosis_roll_forearm&quot;   &quot;kurtosis_picth_forearm&quot;  &quot;kurtosis_yaw_forearm&quot;   
## [41] &quot;skewness_roll_forearm&quot;   &quot;skewness_pitch_forearm&quot;  &quot;skewness_yaw_forearm&quot;    &quot;max_roll_forearm&quot;        &quot;max_yaw_forearm&quot;        
## [46] &quot;min_roll_forearm&quot;        &quot;min_yaw_forearm&quot;         &quot;amplitude_roll_forearm&quot;  &quot;amplitude_yaw_forearm&quot;   &quot;avg_roll_forearm&quot;       
## [51] &quot;stddev_roll_forearm&quot;     &quot;var_roll_forearm&quot;        &quot;avg_pitch_forearm&quot;       &quot;stddev_pitch_forearm&quot;    &quot;var_pitch_forearm&quot;      
## [56] &quot;avg_yaw_forearm&quot;         &quot;stddev_yaw_forearm&quot;      &quot;var_yaw_forearm&quot;
</code></pre>

<p>We removed 58 predictors in the training data frame.</p>

<h3>Remove predictors with high linear correlation</h3>

<p>Next we want to throw out predictors that have a <em>high linear correlation</em>.</p>

<pre><code class="r">#As the correlation matix can only be computed for numeric variables we need to identify numeric variables
colsnumeric &lt;- sapply(training, is.numeric)
#compute the correlation matrix
cortraining &lt;- cor(training[,colsnumeric],use=&quot;pairwise.complete.obs&quot;)
</code></pre>

<p>Within the computed correlation matrix we select all predictors that have a high correlation. Let us define a high corelation as a value <em>equal or greater than 0.7</em>. Thus let&#39;s find these predictors and remove them from the training data set.</p>

<pre><code class="r"># retrieve variables that have a correlation greater or equal to 0.7
highlyCor &lt;- findCorrelation(cortraining, 0.70,verbose=FALSE)
highlyCorcolnames &lt;- colnames(training)[highlyCor]
# remove the highly correlated predictors from the training data frame
training &lt;- training[,-highlyCor]
# print the removed predictors
highlyCorcolnames
</code></pre>

<pre><code>##  [1] &quot;max_roll_dumbbell&quot;        &quot;total_accel_belt&quot;         &quot;var_pitch_belt&quot;           &quot;max_picth_belt&quot;           &quot;pitch_belt&quot;              
##  [6] &quot;accel_belt_z&quot;             &quot;var_pitch_dumbbell&quot;       &quot;var_roll_belt&quot;            &quot;var_total_accel_belt&quot;     &quot;max_roll_belt&quot;           
## [11] &quot;gyros_belt_z&quot;             &quot;min_roll_belt&quot;            &quot;user_name&quot;                &quot;accel_dumbbell_y&quot;         &quot;accel_belt_y&quot;            
## [16] &quot;yaw_belt&quot;                 &quot;pitch_dumbbell&quot;           &quot;accel_belt_x&quot;             &quot;yaw_dumbbell&quot;             &quot;amplitude_pitch_dumbbell&quot;
## [21] &quot;accel_dumbbell_x&quot;         &quot;gyros_dumbbell_z&quot;         &quot;amplitude_roll_dumbbell&quot;  &quot;min_pitch_dumbbell&quot;       &quot;avg_yaw_dumbbell&quot;        
## [26] &quot;var_roll_dumbbell&quot;        &quot;avg_pitch_dumbbell&quot;       &quot;min_pitch_forearm&quot;        &quot;avg_roll_dumbbell&quot;        &quot;accel_dumbbell_z&quot;        
## [31] &quot;magnet_dumbbell_x&quot;        &quot;gyros_arm_z&quot;              &quot;magnet_belt_x&quot;            &quot;var_accel_dumbbell&quot;       &quot;accel_arm_y&quot;             
## [36] &quot;min_yaw_arm&quot;              &quot;avg_roll_belt&quot;            &quot;amplitude_roll_belt&quot;      &quot;amplitude_pitch_belt&quot;     &quot;magnet_arm_x&quot;            
## [41] &quot;accel_forearm_x&quot;          &quot;avg_pitch_belt&quot;           &quot;var_yaw_dumbbell&quot;         &quot;gyros_arm_x&quot;              &quot;gyros_dumbbell_y&quot;        
## [46] &quot;min_pitch_belt&quot;           &quot;avg_yaw_belt&quot;             &quot;gyros_forearm_x&quot;
</code></pre>

<p>We removed 48 highly correlated predictors.</p>

<h3>Remove predictors which are unimportant for prediction</h3>

<p>Now we want to quickly create  a small prediction model in order to query the importance of the variables for the prediction model.
Let&#39;s fit a model, print the important predictors and <em>keep these important predictors</em> in the training data set.</p>

<pre><code class="r">modFit &lt;- train(classe ~.,data=training,method=&quot;rpart&quot;)
# print summary of the model fit
modFit
</code></pre>

<pre><code>## CART 
## 
## 15699 samples
##    47 predictor
##     5 classes: &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (25 reps) 
## 
## Summary of sample sizes: 322, 322, 322, 322, 322, 322, ... 
## 
## Resampling results across tuning parameters:
## 
##   cp          Accuracy   Kappa       Accuracy SD  Kappa SD  
##   0.06329114  0.4787436  0.33855083  0.04631047   0.06483518
##   0.09282700  0.4613826  0.31722356  0.04390608   0.06444678
##   0.20675105  0.3225707  0.09253235  0.07027722   0.10073289
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was cp = 0.06329114.
</code></pre>

<pre><code class="r"># retrieve the variable importance list
importance &lt;- varImp(modFit, scale=FALSE)
importance &lt;- importance[[1]]
# bind the rownames as columns 
importance &lt;- cbind(rownames(importance),importance )
# retrieve column names which have importance greater zero
impcolnames &lt;- importance[importance$Overall&gt;0.0,1]
# print important variables
impcolnames
</code></pre>

<pre><code>##  [1] amplitude_yaw_arm     magnet_belt_y         magnet_dumbbell_y     pitch_forearm         roll_belt             roll_dumbbell        
##  [7] stddev_pitch_belt     stddev_pitch_dumbbell stddev_roll_belt      stddev_roll_dumbbell  stddev_yaw_dumbbell   var_accel_arm        
## [13] var_yaw_belt         
## 47 Levels: accel_arm_x accel_arm_z accel_forearm_y accel_forearm_z amplitude_pitch_forearm amplitude_yaw_arm gyros_arm_y gyros_belt_x ... yaw_forearm
</code></pre>

<pre><code class="r"># retrieve indexes of column names
impcolindex &lt;- which(names(training) %in% impcolnames)
removedCols &lt;- ncol(training) - length(impcolnames)
# keep important columns in training data frame
training &lt;- training[,impcolindex]
</code></pre>

<p>In the last step we have removed 35 unimportant predictors.</p>

<h3>Train final prediction model</h3>

<p>Now that we have reduced the predictors significantly from 160 to <em>13 predictors</em> we will fit a more complex machine learning algorithm based on <em>random forest</em>. Additionally we will use <em>cross validation</em> to minimize the out of sample error and preprocess the training data to remove NA values by knnImpute.</p>

<pre><code class="r">fitControl &lt;- trainControl(method = &quot;repeatedcv&quot;,number = 10, repeats = 3)
preObj &lt;- preProcess(training,method=c(&quot;knnImpute&quot;))
trainingImputed &lt;- predict(preObj,newdata=training)
modFit &lt;- train(trainclasse ~.,data=trainingImputed,
                method=&quot;rf&quot;
              ,trControl = fitControl
              )
# print summary of model
print(modFit)
</code></pre>

<pre><code>## Random Forest 
## 
## 15699 samples
##    12 predictor
##     5 classes: &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 3 times) 
## 
## Summary of sample sizes: 14128, 14131, 14130, 14131, 14128, 14129, ... 
## 
## Resampling results across tuning parameters:
## 
##   mtry  Accuracy   Kappa      Accuracy SD  Kappa SD   
##    2    0.8715837  0.8376083  0.009452852  0.011989397
##    7    0.8978917  0.8708872  0.007758127  0.009805649
##   13    0.8981246  0.8711812  0.008584120  0.010850065
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was mtry = 13.
</code></pre>

<h3>Compute the out of sample error based on a seperate training (or validation) set</h3>

<p>Let&#39;s use our separate test (or validation) set to compute an out of sample error.</p>

<pre><code class="r"># subselect in the test set the predictors used for the training set
traincolnames &lt;- colnames(training)
traincolindex &lt;- which(names(testing) %in% traincolnames)
testing &lt;- testing[,traincolindex]
# impute NAs like for the training set
preObj &lt;- preProcess(testing,method=c(&quot;knnImpute&quot;))
testingImputed &lt;- predict(preObj,newdata=testing)
predictions &lt;- predict(modFit,newdata=testingImputed)
# summarize results
confusionMatrix(predictions, testingclasse)
</code></pre>

<pre><code>## Confusion Matrix and Statistics
## 
##           Reference
## Prediction   A   B   C   D   E
##          A 957 118  20  58   9
##          B  65 475 104  61  14
##          C  20  88 410  42   5
##          D  29  50 127 474  95
##          E  45  28  23   8 598
## 
## Overall Statistics
##                                           
##                Accuracy : 0.7428          
##                  95% CI : (0.7288, 0.7564)
##     No Information Rate : 0.2845          
##     P-Value [Acc &gt; NIR] : &lt; 2.2e-16       
##                                           
##                   Kappa : 0.6744          
##  Mcnemar&#39;s Test P-Value : &lt; 2.2e-16       
## 
## Statistics by Class:
## 
##                      Class: A Class: B Class: C Class: D Class: E
## Sensitivity            0.8575   0.6258   0.5994   0.7372   0.8294
## Specificity            0.9270   0.9229   0.9521   0.9082   0.9675
## Pos Pred Value         0.8236   0.6606   0.7257   0.6116   0.8519
## Neg Pred Value         0.9424   0.9114   0.9184   0.9463   0.9618
## Prevalence             0.2845   0.1935   0.1744   0.1639   0.1838
## Detection Rate         0.2439   0.1211   0.1045   0.1208   0.1524
## Detection Prevalence   0.2962   0.1833   0.1440   0.1976   0.1789
## Balanced Accuracy      0.8922   0.7744   0.7758   0.8227   0.8985
</code></pre>

<pre><code class="r"># compute the out of sample error
outOfSampleAccuracy &lt;- sum(predictions==testingclasse)/length(testingclasse)
outOfSampleAccuracy
</code></pre>

<pre><code>## [1] 0.7427989
</code></pre>

<pre><code class="r">outOfSampleError &lt;- 1-outOfSampleAccuracy
outOfSampleError
</code></pre>

<pre><code>## [1] 0.2572011
</code></pre>

<h3>Compare in sample error and out of bag sample error and out of sample error</h3>

<p>Finally we want to compare the in sample error and the out of bag sample error and the out of sample error based on the seperate test set.  The first two sample errors need to be derived from accuracy variables  stored within the results variable within the prediction model.</p>

<pre><code class="r"># the out of bag sample accuracy of the prediction model
inSampleError &lt;- 1-max(modFit$results$Accuracy)
inSampleError
</code></pre>

<pre><code>## [1] 0.1018754
</code></pre>

<pre><code class="r">cvoutOfSampleError &lt;- 1-max(modFit$results$Kappa)
cvoutOfSampleError
</code></pre>

<pre><code>## [1] 0.1288188
</code></pre>

<p>The in <em>sample error</em> is <strong>10.19%</strong> whereas the <em>out of bag sample error</em> (which is the estimated out of sample error based on training with repeated cross validation) is <strong>12.88%</strong>. Additionally a real <em>out of sample error</em> based on a seperate test (or validation) set is <strong>25.72%</strong>. We observe that the real out of sample error is much higher than the out of bag sample error by about <strong>199.66%</strong>.</p>

</body>

</html>
